/// Encoding Typestate Contracts from https://docs.rust-embedded.org/book/static-guarantees/design-contracts.html

/// GPIO interface
/// enabled     : true = ENABLED, false = DISABLED
/// direction   : true = OUTPUT , false = INPUT
/// mode        : 0 = Low       , 1 = High          , 2 = HighZ

#[flux::opaque]
#[flux::refined_by(enabled:bool, direction: bool, mode: int)]
struct GpioConfig {
    // GPIO Configuration structure generated by svd2rust
    // periph: GPIO_CONFIG,
}

#[flux::opaque]
#[flux::refined_by(val:int)]
enum InputMode {
    #[flux::variant(InputMode[0])]
    PulledLow,
    #[flux::variant(InputMode[1])]
    PulledHigh,
    #[flux::variant(InputMode[2])]
    HighZ,
}

impl GpioConfig {
    #[flux::trusted]
    pub fn get_gpio() -> GpioConfig {
        // GpioConfig { periph: GPIO_CONFIG::take().unwrap() }
        GpioConfig {}
    }

    #[flux::trusted]
    #[flux::sig(fn(me: &strg GpioConfig, is_enabled: bool) ensures me: GpioConfig{v: v.enabled == is_enabled})]
    pub fn set_enable(&mut self, _is_enabled: bool) {
        // self.periph.modify(|_r, w| w.enable().set_bit(is_enabled));
    }

    #[flux::trusted]
    #[flux::sig(fn(me: &strg {GpioConfig[@old] : old.enabled}, is_output: bool) ensures me: GpioConfig[old.enabled, is_output, old.mode] )]
    pub fn set_direction(&mut self, _is_output: bool) {
        // self.periph.modify(|_r, w| w.direction().set_bit(is_output));
    }

    #[flux::trusted]
    #[flux::sig(fn(me: &strg {GpioConfig[@old] : old.enabled && !old.direction }, variant: InputMode) ensures me: GpioConfig[old.enabled, old.direction, variant] )]
    pub fn set_input_mode(&mut self, _variant: InputMode) {
        // self.periph.modify(|_r, w| w.input_mode().variant(variant));
    }

    #[flux::trusted]
    #[flux::sig(fn(me: &strg {GpioConfig[@old] : old.enabled && old.direction }, is_high: bool) ensures me: GpioConfig[old.enabled, old.direction, if is_high { 1 } else { 0 }] )]
    pub fn set_output_status(&mut self, _is_high: bool) {
        // self.periph.modify(|_r, w| w.output_mode.set_bit(is_high));
    }

    #[flux::trusted]
    #[flux::sig(fn(me: &GpioConfig{v: v.enabled && !v.direction }) -> bool)]
    pub fn get_input_status(&self) -> bool {
        // self.periph.read().input_status().bit_is_set()
        true // todo!("get_input_status")
    }
}

impl GpioConfig {
    // Derived methods

    #[flux::sig(fn (me: &strg { GpioConfig[@old] : old.enabled} ) ensures me: GpioConfig[old.enabled, false, 2])]
    pub fn into_input_high_z(&mut self) {
        self.set_direction(false);
        self.set_input_mode(InputMode::HighZ);
    }
}

fn test() {
    /*
     * Example 1: Unconfigured to High-Z input
     */
    let mut pin: GpioConfig = GpioConfig::get_gpio();
    pin.set_enable(true); // DON'T FORGET THIS!

    pin.into_input_high_z();

    /*
     * Example 2: High-Z input to Pulled Low input
     */
    pin.set_input_mode(InputMode::HighZ);

    // Read from the pin
    let _pin_state = pin.get_input_status();

    // Can't do this, currently input mode!
    // pin.set_output_status(true);

    pin.set_input_mode(InputMode::PulledLow);
    let _pin_state = pin.get_input_status();

    /*
     * Example 3: Pulled Low input to Output, set high
     */

    // Don't forget to change to output mode!
    pin.set_direction(true); // DON'T FORGET THIS!

    pin.set_output_status(true);
}
