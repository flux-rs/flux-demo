# Flux => Lean
## Getting Started
To get started, annotate a function that has a `flux_rs::spec` annotation with `flux_rs::proven_externally` and run Flux on the file or package that contains this function with the flag `-Femit_lean_defs` enabled.

For example (while the following can be automatically verified by Flux) we could have:
```rust
#[flux_rs::proven_externally]
#[flux_rs::spec(fn(x: i32{ 0 <= x }, y: i32{ 0 <= y }) ensures x + y >= x && x + y >= y]
fn trivial(_x: i32, _y: i32) {}
```
A new subdirectory should be created (`./lean_proofs`) and flux should fail with an error saying "checking proof for trivial failed".

## Understanding the Structure of the Lean Project
Flux will generate a lake project named `LeanProofs` in a `lean_proofs` subdirectory of the directory where it is run. The project structure will be something like
```
lean_proofs/
|-- lake-manifest.json
|-- lakefile.toml
|-- lean-toolchain
|-- LeanProofs
| |-- LemmaFoo.lean
| |-- LemmaFooProof.lean
| |-- OpaqueFuncDefs.lean
| |-- OpaqueFuncs.lean
| |-- OpaqueFuncsInstance.lean
| |-- OpaqueSortDefs.lean
| |-- OpaqueSorts.lean
| |-- OpaqueSortsInstance.lean
| |-- Structs.lean
|-- README.md
```

### Theorems
Each function marked as `proven_externally` generates a theorem file. For example, a function `foo` will generate `Foo.lean`. It incudes a Lean `theorem` corresponding to the verification condition generated by Flux for the function.

### Proofs
Corresponding to each theorem file, there should be a proof file (e.g. `FooProof.lean`) where the associated theorem should be proven. Flux will generate this file along with the theorem and fill it with a proof by `sorry`. Unlike the theorem files, proof files are not overwritten by Flux after they are created, so that the users can write their proof.

When Flux checks a `proven_externally` function, it calls out to Lean to confirm that its corresponding proof file typechecks. See [below](#proving-the-theorems) for some helpful ideas for doing the proofs.

### Opaque Sorts
If the Flux project contains opaque sort declarations in a `flux_rs::defs!` block, then it will create the following files in the Lean project:
- `OpaqueSortDefs.lean`
- `OpaqueSortsInstance.lean`
- `OpaqueSorts.lean`

`OpaqueSortDefs.lean`  contains the definition of a type class (`FluxOpaqueSorts`) that has one field per opaque sort declaration in Flux. `OpaqueSortsInstance.lean` is where the user provides an instance of the type class in order to give meaning to each opaque sort. `OpaqueSorts.lean` exposes names for the rest of the project to interact with the user provided instance. `OpaqueSortsInstance.lean` is the only file that the user should edit, since the other two are overwritten every time that Flux is run.

### Structs
Flux will generate a `Structs.lean` file where the definitions of structs and enums are encoded as Lean `structures` and `inductive` types. Since these can be refined by values that have opaque sorts, `Structs.lean` depends on `OpaqueSorts.lean`. Note that this dependence *is on the instance of the type class, not the type class itself*.

### Opaque Functions
Opaque functions are handled similarly to opaque sorts, generating corresponding the corresponding files
- `OpaqueFuncDefs.lean`
- `OpaqueFuncsInstance.lean`
- `OpaqueFuncs.lean`

### Regular Functions
Non-opaque refinement functions (functions in `flux_rs::defs!` that have a body) are defined in their own file `FluxDefs.lean`. They can depend on all the other previously defined objects.

## Proving the theorems
To prove a theorem, edit its corresponding proof file. If there are lemmas that can be reused between theorems, a separate file can be created and imported from each proof file. It's also possible to reuse generated theorems to prove subsequent theorems, but because of the way that generation happens, they get quite large, so it's probably better to create shared lemmas.

It's useful to have shared theorems for rewriting occurrences of opaque sorts and functions to their corresponding fields of the user-specified instance of the `FluxOpaqueSorts` and `FluxOpaqueFuncs` type classes. These theorems can be proven by `rfl` and marked `@[simp]` to be applied automatically.

## Solving Constraints with KVars
So far we have ignored kvars, because it's possible to use this tool to prove useful lemmas without ever interacting with them. However, the constraints generated by Flux, often contain kvars (e.g. when there is a loop invariant that Flux must infer). If a function is marked as `proven_externally` and the constraint generated by Flux for it contains kvars, the corresponding theorem in Lean will begin with a sequence of existentially quantified propositions, one for each kvar. To prove the theorem users will have to provide witnesses for the existentially quantified statements.
